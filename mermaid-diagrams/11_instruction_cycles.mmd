---
title: "Multi-Cycle Instruction Execution"
---

## Timeline: Instruction Execution Phases

```mermaid
timeline
    title Instruction Execution Multi-Cycle Process
    
    section Cycle 1 IF
        Fetch : CPU reads instruction from memory
              : Program Counter points to instruction address
              : Instruction loaded into Instruction Register
    
    section Cycle 2 ID
        Decode : Control unit analyzes instruction opcode
               : Determine operation type and required operands
               : Read source registers if needed
    
    section Cycle 3 EX
        Execute : ALU performs the actual computation
                : Address calculation for memory operations
                : Branch condition evaluation
    
    section Cycle 4 MEM
        Memory : Read data from memory for LOAD instructions
               : Write data to memory for STORE instructions
               : Skip this phase for register-only operations
    
    section Cycle 5 WB
        Writeback : Store result in destination register
                  : Update processor flags if needed
                  : Prepare for next instruction
```

## Detailed Pipeline Visualization

```mermaid
flowchart TD
    Start([Instruction Starts]) --> IF[Instruction Fetch<br/>Cycle 1]
    
    IF --> IF_Details{{"üîç Fetch Details"}}
    IF_Details --> IF1["1. PC ‚Üí Memory Address"]
    IF_Details --> IF2["2. Memory ‚Üí Instruction"]
    IF_Details --> IF3["3. Instruction ‚Üí IR"]
    IF1 --> ID
    IF2 --> ID
    IF3 --> ID
    
    ID[Instruction Decode<br/>Cycle 2] --> ID_Details{{"‚öôÔ∏è Decode Details"}}
    ID_Details --> ID1["1. Analyze Opcode"]
    ID_Details --> ID2["2. Identify Operands"]
    ID_Details --> ID3["3. Read Registers"]
    ID1 --> EX
    ID2 --> EX
    ID3 --> EX
    
    EX[Execute<br/>Cycle 3] --> EX_Type{"Instruction Type?"}
    
    EX_Type -->|Arithmetic/Logic| ALU["ALU Operation<br/>ADD, SUB, AND, OR"]
    EX_Type -->|Memory Access| ADDR["Address Calculation<br/>Base + Offset"]
    EX_Type -->|Branch/Jump| BRANCH["Condition Check<br/>Target Address Calc"]
    
    ALU --> MEM_Decision{"Memory Access<br/>Required?"}
    ADDR --> MEM
    BRANCH --> PC_Update["Update PC<br/>(if branch taken)"]
    
    MEM_Decision -->|No| WB
    MEM_Decision -->|Yes| MEM[Memory Access<br/>Cycle 4]
    
    MEM --> MEM_Type{"Memory Operation?"}
    MEM_Type -->|Load| READ["Read from Memory<br/>Memory ‚Üí Data"]
    MEM_Type -->|Store| WRITE["Write to Memory<br/>Data ‚Üí Memory"]
    
    READ --> WB
    WRITE --> WB
    PC_Update --> Complete
    
    WB[Write Back<br/>Cycle 5] --> WB_Details{{"üìù Writeback Details"}}
    WB_Details --> WB1["1. Result ‚Üí Register"]
    WB_Details --> WB2["2. Update Status Flags"]
    WB_Details --> WB3["3. Increment PC"]
    
    WB1 --> Complete
    WB2 --> Complete
    WB3 --> Complete
    
    Complete[Instruction Complete] --> NextInst["Next Instruction<br/>Begins Cycle 1"]
    
    %% Styling
    classDef cycleBox fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef detailBox fill:#f3e5f5,stroke:#4a148c,stroke-width:1px
    classDef decisionBox fill:#fff3e0,stroke:#e65100,stroke-width:2px
    classDef processBox fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    
    class IF,ID,EX,MEM,WB cycleBox
    class IF_Details,ID_Details,WB_Details detailBox
    class EX_Type,MEM_Decision,MEM_Type decisionBox
    class ALU,ADDR,BRANCH,READ,WRITE,PC_Update processBox
```

## Pipelining Visualization

```mermaid
timeline
    title CPU Pipelining Overlapping Instruction Execution
    
    section Clock 1
        Instr 1 : IF Fetch
    
    section Clock 2  
        Instr 1 : ID Decode
        Instr 2 : IF Fetch
    
    section Clock 3
        Instr 1 : EX Execute
        Instr 2 : ID Decode
        Instr 3 : IF Fetch
    
    section Clock 4
        Instr 1 : MEM Memory
        Instr 2 : EX Execute
        Instr 3 : ID Decode
        Instr 4 : IF Fetch
    
    section Clock 5
        Instr 1 : WB Writeback Complete
        Instr 2 : MEM Memory
        Instr 3 : EX Execute
        Instr 4 : ID Decode
        Instr 5 : IF Fetch
    
    section Clock 6
        Instr 2 : WB Writeback Complete
        Instr 3 : MEM Memory
        Instr 4 : EX Execute
        Instr 5 : ID Decode
        Instr 6 : IF Fetch
```

## RISC vs CISC Instruction Cycles

```mermaid
flowchart LR
    subgraph RISC["üèÉ RISC Architecture"]
        direction TB
        R1["Simple Instructions<br/>3-5 cycles each"]
        R2["ADD R1, R2, R3<br/>‚Ä¢ Cycle 1: Fetch<br/>‚Ä¢ Cycle 2: Decode<br/>‚Ä¢ Cycle 3: Execute<br/>‚Ä¢ Cycle 4: Writeback"]
        R3["Uniform 32-bit instructions<br/>Predictable timing"]
        R1 --> R2 --> R3
    end
    
    subgraph CISC["üèóÔ∏è CISC Architecture"]
        direction TB
        C1["Complex Instructions<br/>1-40+ cycles each"]
        C2["MOVE [EBP+8], EAX<br/>‚Ä¢ Cycle 1-2: Fetch (variable length)<br/>‚Ä¢ Cycle 3: Decode complex instruction<br/>‚Ä¢ Cycle 4-5: Address calculation<br/>‚Ä¢ Cycle 6-7: Memory read<br/>‚Ä¢ Cycle 8-10: Execute<br/>‚Ä¢ Cycle 11: Memory write"]
        C3["Variable-length instructions<br/>Unpredictable timing"]
        C1 --> C2 --> C3
    end
    
    RISC -.->|Trade-off| Comparison["‚öñÔ∏è Design Philosophy<br/><br/>RISC: More instructions, faster execution<br/>CISC: Fewer instructions, complex execution<br/><br/>RISC: Better for pipelining<br/>CISC: More powerful single instructions"]
    CISC -.-> Comparison
    
    %% Styling
    classDef riscStyle fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef ciscStyle fill:#fff3e0,stroke:#e65100,stroke-width:2px
    classDef compStyle fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    
    class R1,R2,R3 riscStyle
    class C1,C2,C3 ciscStyle
    class Comparison compStyle
```

## Real-World Example: Different Instruction Types

```mermaid
flowchart TD
    Start([Different Instructions,<br/>Different Cycle Counts])
    
    Start --> Simple["Simple Register Operation<br/>ADD R1, R2, R3"]
    Start --> Memory["Memory Load Operation<br/>LOAD R1, [Memory_Address]"]
    Start --> Complex["Complex Operation<br/>DIVIDE R1, R2"]
    
    Simple --> Simple_Cycles["üìä 3-4 Cycles<br/>‚Ä¢ Fetch: 1 cycle<br/>‚Ä¢ Decode: 1 cycle<br/>‚Ä¢ Execute: 1 cycle<br/>‚Ä¢ Writeback: 1 cycle"]
    
    Memory --> Memory_Cycles["üìä 4-5 Cycles<br/>‚Ä¢ Fetch: 1 cycle<br/>‚Ä¢ Decode: 1 cycle<br/>‚Ä¢ Address Calc: 1 cycle<br/>‚Ä¢ Memory Access: 1-2 cycles<br/>‚Ä¢ Writeback: 1 cycle"]
    
    Complex --> Complex_Cycles["üìä 10-40 Cycles<br/>‚Ä¢ Fetch: 1 cycle<br/>‚Ä¢ Decode: 1 cycle<br/>‚Ä¢ Execute: 8-38 cycles<br/>‚Ä¢ Writeback: 1 cycle"]
    
    Simple_Cycles --> Factors
    Memory_Cycles --> Factors
    Complex_Cycles --> Factors
    
    Factors["‚ö° Factors Affecting Cycle Count<br/><br/>1. Memory latency (cache hits/misses)<br/>2. Instruction complexity<br/>3. Data dependencies<br/>4. Branch predictions<br/>5. Pipeline stalls<br/>6. Floating-point operations"]
    
    %% Styling
    classDef simpleStyle fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef memoryStyle fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef complexStyle fill:#ffebee,stroke:#c62828,stroke-width:2px
    classDef factorStyle fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    
    class Simple,Simple_Cycles simpleStyle
    class Memory,Memory_Cycles memoryStyle
    class Complex,Complex_Cycles complexStyle
    class Factors factorStyle
```

## Variable-Length vs Uniform-Length Instructions

```mermaid
flowchart TD
    Title["üéØ Instruction Length: Architecture Design Choice"]
    
    Title --> RISC_Side["üèÉ RISC: Uniform Instructions"]
    Title --> CISC_Side["üèóÔ∏è CISC: Variable-Length Instructions"]
    
    %% RISC Side
    RISC_Side --> RISC_Example["üìè All Instructions = 32 bits<br/><br/>ADD R1, R2, R3    ‚Üê 32 bits<br/>SUB R4, R5, R6    ‚Üê 32 bits<br/>LOAD R7, [R8]     ‚Üê 32 bits<br/>STORE R9, [R10]   ‚Üê 32 bits"]
    
    RISC_Example --> RISC_Benefits["‚úÖ RISC Benefits"]
    RISC_Benefits --> RB1["üéØ Predictable Fetch:<br/>Next instruction always<br/>at CurrentPC + 4"]
    RISC_Benefits --> RB2["‚ö° Fast Decode:<br/>Fixed instruction format<br/>enables parallel decode"]
    RISC_Benefits --> RB3["üîÑ Efficient Pipeline:<br/>No variable-length stalls<br/>Better branch prediction"]
    RISC_Benefits --> RB4["üß† Simple Control Logic:<br/>Reduced complexity<br/>Higher clock speeds"]
    
    %% CISC Side  
    CISC_Side --> CISC_Example["üìè Variable Instruction Sizes<br/><br/>MOV AL, 42         ‚Üê 2 bytes<br/>ADD EAX, EBX       ‚Üê 2 bytes<br/>MOV EAX, [EBP+8]   ‚Üê 3 bytes<br/>IMUL EAX, [ESI+4], 10 ‚Üê 6 bytes<br/>REP MOVSB          ‚Üê 2 bytes<br/>CALL DWORD PTR [EAX+8] ‚Üê 6 bytes"]
    
    CISC_Example --> CISC_Benefits["‚úÖ CISC Benefits"]
    CISC_Benefits --> CB1["üíæ Code Density:<br/>More functionality<br/>per instruction"]
    CISC_Benefits --> CB2["üé™ Complex Operations:<br/>Single instruction can<br/>do multiple operations"]
    CISC_Benefits --> CB3["üì¶ Smaller Programs:<br/>Fewer instructions needed<br/>for same functionality"]
    
    CISC_Example --> CISC_Challenges["‚ùå CISC Challenges"]
    CISC_Challenges --> CC1["üêå Variable Fetch Time:<br/>Don't know instruction length<br/>until partially decoded"]
    CISC_Challenges --> CC2["üß© Complex Decode:<br/>Multiple decode cycles<br/>for complex instructions"]
    CISC_Challenges --> CC3["‚ö†Ô∏è Pipeline Complexity:<br/>Variable timing makes<br/>pipelining difficult"]
    
    %% Comparison Section
    RB4 --> Comparison["‚öñÔ∏è Architecture Trade-offs"]
    CC3 --> Comparison
    
    Comparison --> Trade1["üèÉ RISC Philosophy:<br/>Simple instructions, fast execution<br/>More instructions, predictable timing"]
    Comparison --> Trade2["üèóÔ∏è CISC Philosophy:<br/>Complex instructions, versatile execution<br/>Fewer instructions, variable timing"]
    
    %% Technical Details
    Trade1 --> TechRISC["üîß RISC Technical Details"]
    TechRISC --> TR1["‚Ä¢ Fixed 32-bit encoding<br/>‚Ä¢ Immediate operands limited<br/>‚Ä¢ Simple addressing modes<br/>‚Ä¢ Load/Store architecture"]
    
    Trade2 --> TechCISC["üîß CISC Technical Details"]  
    TechCISC --> TC1["‚Ä¢ 1-15 byte instructions (x86)<br/>‚Ä¢ Complex addressing modes<br/>‚Ä¢ Memory-to-memory operations<br/>‚Ä¢ Variable operand encoding"]
    
    %% Modern Impact
    TR1 --> Modern["üöÄ Modern Impact"]
    TC1 --> Modern
    
    Modern --> M1["üì± ARM (RISC): Dominates mobile<br/>Power efficiency crucial"]
    Modern --> M2["üíª x86 (CISC): Still strong in desktop/server<br/>Backward compatibility important"]
    Modern --> M3["üîÑ Hybrid Approaches:<br/>CISC instructions ‚Üí RISC Œº-ops<br/>Best of both worlds"]
    
    %% Styling
    classDef riscStyle fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef ciscStyle fill:#fff3e0,stroke:#e65100,stroke-width:2px
    classDef benefitStyle fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef challengeStyle fill:#ffebee,stroke:#c62828,stroke-width:2px
    classDef comparisonStyle fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef modernStyle fill:#f1f8e9,stroke:#558b2f,stroke-width:2px
    
    class RISC_Side,RISC_Example,RB1,RB2,RB3,RB4,TechRISC,TR1 riscStyle
    class CISC_Side,CISC_Example,CB1,CB2,CB3,TechCISC,TC1 ciscStyle
    class RISC_Benefits,CISC_Benefits benefitStyle
    class CISC_Challenges,CC1,CC2,CC3 challengeStyle
    class Comparison,Trade1,Trade2 comparisonStyle
    class Modern,M1,M2,M3 modernStyle
```

## Instruction Fetch Comparison

```mermaid
timeline
    title Instruction Fetch RISC vs CISC Timing
    
    section RISC Fetch Pattern
        Cycle 1 : Fetch 32-bit instruction at PC
                : Decode starts immediately
                : PC equals PC plus 4 predictable
        
        Cycle 2 : Fetch next 32-bit instruction at PC plus 4
                : Previous instruction in decode
                : Pipeline flows smoothly
        
        Cycle 3 : Fetch next 32-bit instruction at PC plus 8
                : Consistent 4-byte increments
                : No fetch stalls
    
    section CISC Fetch Pattern
        Cycle 1 : Fetch first bytes at PC
                : Don't know instruction length yet
                : Partial decode to determine size
        
        Cycle 2 : May need additional fetch
                : Instruction could be 1-15 bytes
                : PC increment unknown until decode
        
        Cycle 3 : Complete instruction decode
                : Finally know next PC value
                : Pipeline may stall waiting
```